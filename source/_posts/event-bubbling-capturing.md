---
title: Event Bubbling and Event Capturing
date: 2019-05-16 20:13:40
tags:
---
<br>
<br>
<img src="https://raw.githubusercontent.com/mohitsparihar/massets/master/bubbles.jpg" style="float:center; margin: 0 auto;" />
<br>
<br>
Javascript enables our web apps to be interactive. It can recognize events generated by a user such as a mouse click, scrolling on a mouse wheel, pressing down on a key of the keyboard, etc... Handling these types of user actions smoothly is important for a great user experience. Today, we will learn how we can efficiently handle JavaScript events using mouse click events as an example.

 ## **`addEventListener`** method
 
JavaScript has a built-in method called addEventListener which you can append onto HTML nodes. It takes in a total number of 3 arguments as follows:

1. Name of an event.
2.The callback function to run some code when the specified event is triggered.

3. Optional:the Boolean value of capture. (Set to false by default).

 ```html
<div id="div1">I am a div1</div>
```
```javascript
const div1 = document.getElementById("div1");

div1.addEventListener("click", function() {
  console.log("div1 clicked");
});
```
<iframe width="100%" height="100" src="//jsfiddle.net/mohitmogambo/2Lrgkh9o/4/embedded/result/dark/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

As you would expect, clicking on 'I am a div' text will alert 'div1 clicked' on the browser. Let's wrap the text with a new div in the HTML. Can you guess what the output is now if you click on the text?
```html
<div id="div1">
  <div id="div2">I am a div2</div>
</div>
```
```js
const div1 = document.getElementById("div1");

div1.addEventListener("click", function() {
  alert("div1 clicked");
});
```
<iframe width="100%" height="150" src="//jsfiddle.net/mohitmogambo/2Lrgkh9o/8/embedded/result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

The result stays the same and prints "I am a div1" even though we clicked on the div with the id of 'div2'.

## Event bubbling

By default, events bubble in JavaScript. Event bubbling is when an event will traverse from the most inner nested HTML element and move up the DOM hierarchy until it arrives at the element which listens for the event. This move is also popularly known as Event Propagation or Event Delegation.

In the above example, Clicking on the text 'I am a div1' is equivalent to clicking on #div2. Because we have the event listener on the parent element #div1, the event starts the most inner child #div2 and bubbles up.

Here is an additional example. Let's also attach an event listener to the div2 in JavaScript.

```html
<div id="div1">
  <div id="div2">I am a div</div>
</div>
```
```js
const div1 = document.getElementById("div1");
const div2 = document.getElementById("div2");

div1.addEventListener("click", function() {
  console.log("div1 clicked");
});
div2.addEventListener("click", function() {
  console.log("div2 clicked");
});
```
Here is the result of event bubbling.
```
div2 clicked
div1 clicked
```
Note we can also add event listeners to root level elements such as html and body, the events will bubble until then. This is the hierarchy:

**`Target -> Body -> HTML -> Document -> Window`**

## Stop propagation

Sometimes, you don't want events to trave in a direction, then you can use stopPropagation() of the event object. The event object is provided as a parameter in the callback function.

```js
div2.addEventListener("click", function(event) {
  event.stopPropagation();
  console.log("div2 clicked");
});
```
Result:
```bash
div2 clicked
 ```

## Practical Use of Event bubbling

Let's say you are making a to-do list app with pure JavaScript which users can click on a to-do item to toggle it as completed back and forth. Adding individual event listeners to each to-do item is unreasonable because

The list could be very long. (The process becomes tedious. Yes, you can run a loop to add event listeners but having too many event listeners in an app will consume lots of browser memory and will slow down the app)
New todo items can be added dynamically. (No way to add event listeners to them)
We can solve this problem by attaching an event listener to the parent element that contains the list. Take a close look at what the following code does.
```html
<ul class="list">
    <li class="item">Wash dishes</li>
    <li class="item">Walk your dog</li>
    <li class="item">Laundary</li>
    <li class="item">click on the to do item</li>
</ul>
<style>
    .completed {
        text-decoration: line-through;
    }
    .item {
      border: 1px solid red;
      margin-bottom: 1px;
    }
</style>
```
```js
const list = document.querySelector(".list");

list.addEventListener("click", e => {
    e.target.classList.toggle("completed")
})
```
<iframe width="100%" height="200" src="//jsfiddle.net/mohitmogambo/2Lrgkh9o/17/embedded/result/" allowfullscreen="allowfullscreen" allowpaymentrequest frameborder="0"></iframe>

Clicking on an item will toggle class of completed to that specific element which adds a strike-through to the text. It also generates an event object which has target property. Using e.target refers to the DOM that was clicked, which you can add classList and toggle to toggle a class.

## Event Delegation

Event delegation takes advantage of event propagation and so, allows the event listener to be set on a parent element, thus avoiding adding event listeners to specific nodes. That event listener analyses bubbled events to match itself or any child elements to pass to an event handler.

In this example, the bubbling side-effect of firing all event handlers on all elements with that event is gone but the functionality is retained. — The event listener is set on a parent element which listens for click events. If this parent element is clicked, the callback will compare event.target (element which was clicked) against a common property. E.g — if event.target is a list item, log its contents.

```html
<!-- HTML CONTENT OF THE CODE -->
<ul class="list">
    <li class="item">Wash dishes</li>
    <li class="item">Walk your dog</li>
    <li class="item">Laundary</li>
    <li class="item">click on the to do item</li>
</ul>
```
```css
/* CSS PART FOR THE CODE */
    .completed {
        text-decoration: line-through;
    }
    .item {
      border: 1px solid red;
      margin-bottom: 1px;
    }
```
```js
//JAVASCRIPT PART OF THE CODE
const list = document.querySelector(".list");
const result = document.getElementById("result");

list.addEventListener("click", e => {
    console.log(e.target.innerText); // <li class="item completed">Walk your dog</li>
    e.target.classList.toggle("completed")
});
```
<iframe
     src="https://codesandbox.io/embed/magical-glade-kst35?expanddevtools=1&fontsize=14&hidenavigation=1&theme=dark&view=preview"
     style="width:100%; height:400px; border:0; border-radius: 4px; overflow:hidden;"
     title="magical-glade-kst35"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-autoplay allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

In this example the event listener is set on the ul element, the callback checks if the event target belongs to a group of elements with class `‘list’`, if so, list container containing the `item` class will also be called. The particular `item` class *`li`* element will now get strike through.

When you add an event listener for a certain event, the name of the event listener is added to a list. Then, when the event occurs, a loop goes through the event listeners in the list and calls the appropriate method for each one individually. So the event listener is just an ordinary object, and the “listening” methods are just ordinary methods that get called by other code at the appropriate time.

Another way to add event listeners dynamically would have been on creation of each li element of of a note, an event listener would have been added for each note. If a page would have hundreds of these elements, each with it’s own event listener method it can use up a lot of memory.

### target vs currentTarget

This is a common confusion that most of the people encounter. We just learned target refers to the DOM that triggered the event. CurrentTarget will refer to the DOM that the event listener is listening on. Let's console log e.target and e.currentTarget inside the function.
```js
const list = document.querySelector(".list");

list.addEventListener("click", e => {
    console.log(e.target); // <li class="item completed">Walk your dog</li>
    console.log(e.currentTarget); // <ul class="list"></ul>
    e.target.classList.toggle("completed")
})
```
*If the parent element has an event listener but we stop event propagation in the child, the currentTarget refers to the DOM that stopped the propagation*

## Event capturing

To turn this on, pass `true` as the 3rd argument to the `addEventListener` method.
```js
Element.addEventListener("click", function(){}, true);
```
This type of propagation is rarely used. Instead of working from inner to outer it flips the direction and goes from outer to inner. Here is the hierarchy.

**`Window -> Document -> HTML -> Body -> Target`**

So you would use this if you want to first get hold of the parent element that the event is listening to. Let's use one of the previous examples.
```html
<div id="div1">
  <div id="div2">I am a div</div>
</div>
```
```js
const div1 = document.getElementById("div1");
const div2 = document.getElementById("div2");

div1.addEventListener("click", function() {
  console.log("div1 clicked");
}, true);
div2.addEventListener("click", function() {
  console.log("div2 clicked");
});
```
Result

<iframe
     src="https://codesandbox.io/embed/clever-tereshkova-205r6?expanddevtools=1&fontsize=14&hidenavigation=1&moduleview=1&theme=dark&view=preview"
     style="width:100%; height:400px; border:0; border-radius: 4px; overflow:hidden;"
     title="clever-tereshkova-205r6"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-autoplay allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>

Earlier in the same exaple you saw that on clicking on the inside div i.e. `div2` we used to get an output showing 
```bash
div2 is clicked
div1 is clicked
```
now we are getting the opposite of that.
First the outer div is called then the inner one in called.
This is called as Event Capturing.